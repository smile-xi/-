Service: Mysql@localhost:3306
User: root
Password: hxr001223
连接名：192.168.0.103

sql查询语句执行顺序
     select
         字段名-------------5
      from
          表名---------------1
      where
          条件---------------2
      group by
         ... ------------------3
      having
          ... -----------------4
       order by
          ... -----------------6
      limit  0,5;  -----------7(取查询到的结果的前五条数据，mysql特有语法)0代表从哪开始取，5代表取5个
     所有的分组函数都是在group by之后执行的。

创建数据库：create database 数据库名;
删除数据库：drop database 数据库名;
使用该数据库：use 数据库名;

mysql8.0.19获取连接的方式：jdbc:mysql://localhost:3306/数据库名? useUnicode=true&characterEncoding=utf8&serverTimezone=GMT
（注意：xml中的&需要用&amp;转译代替）
	driver：com.mysql.cj.jdbc.Driver
    

1. \c 命令，结束一条语句。

2.exit 命令，退出mysql。

3.查看表的创建语句：
   show create table 表名;

4.查看mysql的版本号：
  select version();

5.简单的查询语句（DQL）
  语法格式：
     select  字段名1,字段名2,字段名3,.......  from  表名;
   提示：任何一条sql语句以分号结尾。
   提示：sql语句不区分大小写。

6.查看表结构：
   desc  表名;
  查看其他库中的表：
  show tables from<database name>;

7.sql语句当中的中文用单引号括起来,例如: '中文'

8.给字段更名：
   原字段名 as 新字段名
   （as关键字可以省略，用空格代替）
  
9.条件查询:
  select 字段... from 表名 where 条件;

10.between ... and ... 是闭区间 [ ]

11.and代表并且，or代表或者、和，加了小括号()的先执行

12.in等同于 和，使用语法：
          in('字段名1','字段名2')

13.模糊查询 like
     （在模糊查询当中，必须掌握两个特殊的符号,一个是%一个是_）
       %代表任意多个字符，_代表任意1个字符。
        例如：select * from 表名 where name like '%o%';
               //找出名字中含有o的

                 select * from 表名 where name like '_A%';
              //找出名字中第二个字母是A的(如果是第n个字母就加n-1个_)

                  select * from 表名 where name like '%\_%';
              //找出名字中带有_的 (\为有转意字符)

14.排序（升序、降序）
        order by;（sql语句中最后执行）
        asc代表升序，desc代表降序；
         例如：select * from 表名 order by 字段名;   //按照字段名排序，默认为升序
         例如：select * from 表名 order by 字段名 asc;  //按照字段名排序，为升序
         例如：select * from 表名 order by 字段名 desc;  //按照字段名排序，为降序     
         例如：select  字段1,字段2,字段3  from  表名  order  by  2;  //按照字段2排序
         例如：select * from 表名 where 条件 order by 字段名;  //在有条件的情况下排序
                 
15.sql查询语句执行顺序
     select
         字段名-------------5
      from
          表名---------------1
      where
          条件---------------2
      group by
         ... ------------------3
      having
          ... -----------------4
       order by
          ... -----------------6
     
     order by是最后执行的。

16.空处理函数：
       语法：ifnull(可能为null的数据,被当做什么处理),
                 //可以对数据进行提前处理
       例如：select ifnull('工资补助',0) as '工资补助' from 表名;
                    //这样做工资补助为null的位置都会替换成0

17.group by 和 having
     group by：按照某个字段或某些字段进行分组。
     having：having是对分组之后的数据进行再次过滤。

18.查询结果集的去重：
     在需要去重的字段前面加上 distinct 关键字 ,例如：
      select distinct 字段 from 表名;
    注意：distinct 只能出现在所有字段的最前面，distinct之后的所有字段联合去重，不同字段之间用逗号隔开。

19.表的别名：
    例如：select  a.字段1,b.字段2  from  表名1  a,表名2  b;
    好处：执行效率高，可读性好。

20.笛卡尔积现象：
        当两张表进行连接查询时，如果没有任何的条件限制，最终的查询结果是两张表记录条数的乘积。

21.避免了笛卡尔积现象能不能提高效率？
    不能，匹配的次数不会减少，只是过滤掉了无效记录，只显示有效记录。

22.多表连接：
    语法：
    select 
        字段1，字段2，字段3......
    from
        表1
    join        -----------------内连接，表1与表2进行内连接
        表2
     on
        连接条件1
    join        -----------------内连接，表1与表3进行内连接
        表3
     on
        连接条件2
    left join   -----------------外连接，表1与表4进行左外连接
        表4
     on
        连接条件3
     .....

23.union
   可以把两张不相干的表中的数据拼接到一块显示（查询的列的数量必须得一致）
     语法：
       select  字段1  from  表1
       union
       select  字段2  from  表2;
     查询结果会显示字段1的名字，不显示字段2

24.limit
     limit用来做分页查询，语法规则如下：
     select * from 表名 where 条件 limit 起始下标,展示的数据条数；（如果要展示第四条到第九条的数据：limit 3，6；）

25.创建表
    语法：create table 表名(字段名1 数据类型 ，
                                        字段名2 数据类型 约束，
                                        字段名3 数据类型 default 默认值);
   注意：约束和default可加可不加。

26.insert 语句插入数据
     语法格式：
            insert into 表名(字段名1，字段名2，字段名3......) values(值1，值2，值3......);
            要求：字段的数量和值的数量相同，并且数据类型要对应相同。

            如果给一行中每一列字段都插入数据：
            insert into 表名 values(值1，值2，值3......);
            注意：这种方法添加记录必须保证values添加的值与表的顺序对应。

            如果要一次插入多行数据：
            insert into 表名(字段名1，字段名2，字段名3......) values(值1，值2，值3......),(值4，值5，值6......),(值x，值y，值z......),......;

27.删除表
     语法：
      drop table if exists 表名;
       //如果该表存在的话，把它删除（mysql支持，Oracle不支持）
      drop table  表名；
       //通用语句

28.表的复制
      语法：
       create table 表名1 as select * from 表名2；
       //创建一张表，名叫“表名1”，同时把 select * from 表名2；的查询结果复制给“表名1”。

       insert into 表名1 select * from 表名2;
       //把 select * from 表名2; 的查询结果插入到“表名1”中。

29.修改数据 update
     语法格式：
         update 表名 set 字段名1=值1，字段名2=值2... where 条件；
           注意：没有条件整张表全部更新。

30.删除数据 delete
     语法格式：
        delete from 表名 where 条件；
           注意：没有条件全部删除。

31.如何删除大表（重点）
     语法格式：
         truncate table 表名;
          注意：该方法删完表以后无法回滚(恢复)，永久丢失，需谨慎使用。

32.非空约束  not null
     语法：
         create table 表名(字段名 数据类型 not null);
          创建表后添加记录时加有该约束的字段不能为null值。

33.唯一性约束 unique
      唯一约束修饰的字段具有唯一性，不能重复，但可以为null。
      语法：
           create table 表名(字段名 数据类型 unique);   //【列级约束】

      如何让两个字段或者多个字段联合起来具有唯一性呢？
      语法：
                create table 表名(字段名1 数据类型 ，
                                          字段名2 数据类型 ，
                                           unique(字段名1，字段名2)  //多个字段联合起来添加一个约束，【表级约束】
                                          );
           
34.主键约束   primary key    简称：pk
     主键约束修饰的字段既不能为null，也不能重复。
     语法：
          create table 表名(字段名 数据类型 primary key);   //【列级约束】
     注意：一张表的主键约束只能有一个。

35.mysql提供主键值自增（重点）
     语法：
         create table 表名(id int primary key auto_increment);
         // id字段自动维护一个自增的数字，从1开始，以1递增。

36.外键约束  foreign key    简称：fk
     1. 外键修饰的字段可以为null。
     2.外键约束引用的字段必须有唯一性。
      例：             两张表
        语法：
          t_class:  create table t_class(cno int,cname varchar(255),primary key(cno));
          t_student:  create table t_student(sno int,sname varchar(255),classno int,
                                                             foreign key(classno) references t_class(cno),  //外键约束，t_student表引用t_class表，
                                                             primary key(sno));                                           指classno字段中的记录只能是cno字段中已有的记录

     t_class  班级表
     cno(pk)                    cname
     ------------------------------------------------
     101                          高三1班
     102                          高三2班

    t_student  学生表
    sno(pk)                     sname                         classno(该字段添加外键约束fk)
    ---------------------------------------------------------------------------------
    1                               一号                             101 
    2                               二号                             101
    3                               三号                             102
    4                               四号                             102
    5                               五号                             102

  t_student中 的classno字段引用 t_class 表中的cno字段，此时 t_student 叫做子表，t_class 叫做父表。
  顺序要求：
    删表的时候先删子，再删父，
    创建表的时候先创父，再创子，
    添加数据先添加父，再添加子。

37.事务（Transaction）

     start transaction;(开始事务)：启动事务机制。
     commit;（提交）：提交事务，同时把事务结束。
     savepoint 标识符;(存档):设置存档点，使用回滚的时候可以选择性回到该位置。
     rollback;（回滚）：回滚事务，把事务回滚到上一次的提交点或者存档点(此时的语法为：rollback 标识符;)，同时把事务结束。

     1.什么是事务？
        一个事务是一个完整的业务逻辑单元，不可再分。
        比如：银行账户转账，从A账户向B账户转账10000，需执行两条update语句：
               update t_act set balance=balance-10000 where actno='act-001';
               update t_act set balance=balance+10000 where actno='act-002';

        以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。
      
        要想保证以上两条DML语句同时成功或者同时失败，那么必须使用数据库的"事务机制"。

     2.和事务相关的语句只有DML语句（insert delete update）。
        因为他们这三个语句都是和数据库当中的"数据"相关的。
        事务的存在是为了保证数据的完整性，安全性。

     3.事务执行原理及过程：
          手机相册。

      4.事务的四大特性（ACID）
          A：原子性：事务是最小的工作单元，不可再分。
          C：一致性：事务必须保证多条DML语句同时成功或者同时失败。
          I：隔离性：事务A与事务B之间具有隔离。
          D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。

      5.关于事务之间的隔离性
              事务隔离性存在隔离级别，理论上隔离级别包括4个：
                    第一级别：读未提交（read uncommitted）
                                    //对方事务还未提交，我们当前事务可以读取到对方未提交的数据。
                                       读未提交存在脏读现象（Dirty Read）现象：表示读到了脏的数据。
                    第二级别：读已提交（read committed）
                                    //对方事务提交之后的数据我方可以读取到，这种隔离级别解决了脏读现象。
                                       读已提交存在的问题是：不可重复读。
                    第三级别：可重复读（repeatable read）
                                    //这种隔离级别解决了不可重复读问题。
                                       存在的问题：读取到的数据是幻想。
                    第四级别：序列化读/串行化读（serializable）
                                   //解决了所有问题。
                                      效率低，需要排队。
      
              Oracle数据库默认的隔离级别是：读已提交。
              mysql数据库默认的隔离级别是：可重复读。

              如何设置隔离级别：
                语法：set global transaction isolation level 隔离级别(如：read uncommitted) ;
             
              如何查看事务隔离级别：
                语法：select @@global.tx_isolation;(老版本)
                          select @@transaction_isolation;(新版本)
           
         6.如何开始事务
                       mysql事务默认情况下是自动提交的。
                    （什么是自动提交？只要执行任意一条DML语句则提交一次）怎么关闭自动提交？ start transaction;(开始事务)

38.索引

      语法：
               create index 索引名称 on 表名(字段名);               例：create index emp_sal_index on emp(sal);
               //创建索引

               drop index 索引名称;                                例：drop index emp_sal_index on emp;
               //删除索引
          
     1.在是数据库方面，查询一张表的时候有两种检索方式：
        第一种：全表扫描。
        第二种：根据索引检索（效率很高）

     2.原理：缩小了扫描的范围。

     3.索引虽然可以提高检索效率，但也不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。
       比如：表中的数据经常被修改，这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。
      
     4.添加索引是给某一个字段，或者说某些字段添加的。
       什么时候考虑给字段添加索引？
        * 数据量庞大。（根据客户需求）
        * 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）
        * 该字段经常出现在where子句中。（经常根据哪个字段查询）

      5.主键和具有unique约束的字段自动会添加索引。
          所以根据主键查询效率较高，尽量根据主键检索。

      6.索引的分类：
            单一索引：给单个字段添加索引。
            复合索引：给多个字段联合起来添加索引。
            主键索引：主键上会自动添加索引。
            唯一索引：有unique约束的字段上会自动添加索引。

       7.索引什么时候失效：
              使用模糊查询的时候，第一个通配符使用的是%，这时候索引是失效的，例如：
                      select ename from emp where ename like '%A%';

        8.索引的实现原理：
                  手机相册！！
     
39.视图（view）
      1.什么是视图？
          站在不同的角度去看数据。（同一张表的数据，通过不同的角度去看待）
       
      2.怎么创建视图？怎么删除视图？
         语法：
         create view 视图名 as DQL语句；     //创建视图    例如：create view myview as select empno,ename from emp;
         drop view 视图名;            //删除视图   例如：drop view myview;
 
      3.对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据，不是直接操作原表）

      4.视图的作用：
             可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，程序员只对视图对象进行操作。

40.DBA命令
      1.将数据库当中的数据导出：
             在windows的dos命令窗口中执行：
                  mysqldump 需要导出的数据库（如：school）>导出后的位置（如：D:\school.sql） -uroot -p数据库密码

      2.导入数据
              1.先创建数据库：create database 数据库名;
              2.使用该数据库：use 数据库名;
              3.导入sql脚本：source  sql脚本;

41.数据库设计三范式（重点）
       1.什么是设计范式？
           设计表的依据。按照三范式设计的表不会出现数据的冗余。

       2.三范式有哪些？
           第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。           
           第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。
                      //口诀：多对多？三张表，关系表两个外键。
           第三范式：建立在第二范式的基础只是，所有非主键字段直接依赖主键，不能产生传递依赖。
                      //口诀：一对多？两张表，多的表加外键。

42.一对一怎么设计？
       两种设计方案：
            1.主键共享：详情手机相册！
            2.外键唯一：详情手机相册！

43.行级锁（悲观锁）：
           对于被加了行级锁的记录，只要在当前事务还未结束，其他事务或其他线程就无法对该记录进行修改！
          语法：
               select 字段名 from 表名 where 条件  for update;
                //满足该条件的所有记录都会被加上行级锁，注意：这里的记录是指完整的表中的记录，而非针对所写的字段名的那列记录。